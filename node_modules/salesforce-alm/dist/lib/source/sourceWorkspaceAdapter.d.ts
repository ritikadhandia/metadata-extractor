import { AsyncCreatable } from '@salesforce/kit';
import { Logger } from '@salesforce/core';
export declare class SourceWorkspaceAdapter extends AsyncCreatable<SourceWorkspaceAdapter.Options> {
    logger: Logger;
    wsPath: string;
    defaultPackagePath: string;
    isStateless: boolean;
    spsm: any;
    metadataRegistry: any;
    sourceLocations: any;
    namespace: string;
    defaultSrcDir: string;
    fromConvert: boolean;
    forceIgnore: any;
    pendingSourcePathInfos: Map<any, any>;
    pendingDirectories: any[];
    changedSourceElementsCache: any;
    allAggregateSourceElementsCache: any;
    /**
     * @ignore
     */
    constructor(options: SourceWorkspaceAdapter.Options);
    protected init(): Promise<void>;
    revertSourcePathInfos(): void;
    backupSourcePathInfos(): void;
    /**
     * Get AggregateSourceElements (ASEs) in the workspace.
     *
     * To get all ASEs: SourceWorkspaceAdapter.getAggregateSourceElements(false);
     *    NOTE: This caches all ASEs so that subsequent calls do not incur this perf hit and just return the cache.
     *
     * To get all changed ASEs: SourceWorkspaceAdapter.getAggregateSourceElements(true);
     *
     * To get only ASEs from a certain path: SourceWorkspaceAdapter.getAggregateSourceElements(false, undefined, undefined, myPath);
     *
     * @param {boolean} changesOnly - If true then return only the updated source elements (changed, new, or deleted)
     * @param {string} packageDirectory - the package directory from which to fetch source
     * @param {boolean} updatePendingPathInfos - the pending path infos should only be updated the first time this method is called
     *      in order to prevent subsequent calls from overwriting its values
     * @param {string} sourcePath the directory or file path specified for change-set development
     * @returns {Map<String, AggregateSourceElement>} - Map of aggregate source element key to aggregateSourceElement
     * ex. { 'ApexClass__myApexClass' : aggregateSourceElement }
     */
    getAggregateSourceElements(changesOnly: boolean, packageDirectory?: string, updatePendingPathInfos?: boolean, sourcePath?: string): any;
    /**
     * Commit pending changed file infos
     * @returns {boolean} - Was the commit successful
     */
    commitPendingChanges(): boolean;
    /**
     * Update the source stored in the workspace
     * @param sourceElements - Collection of source elements to update
     */
    updateSource(sourceElements: any, force: any, sOrgApi: any, manifest?: any, checkForDuplicates?: any, unsupportedMimeTypes?: any): any;
    /**
     * Create a source element representation of a metadata change in the local workspace
     * @param fileProperty - The file property from the retrieve result
     * @returns {null} - A source element or null if metadataType is not supported
     */
    processMdapiFileProperty(changedSourceElements: any, retrieveRoot: any, fileProperty: any, bundleFileProperties: any): any;
    /**
     * Create a source element representation of a deleted metadata change in the local workspace
     * @returns {null} - A source element or null if metadataType is not supported
     */
    handleObsoleteSource(changedSourceElements: Map<string, any>, fullName: string, type: string): any;
    private warnUser;
}
/**
 * Adapter between scratch org source metadata and a local workspace
 */
export declare namespace SourceWorkspaceAdapter {
    /**
     * Constructor Options for and Org.
     */
    interface Options {
        /**
         * The org that the source workspace files belong to
         */
        org: any;
        /**
         * The name of the default package path to which new source will be added
         */
        defaultPackagePath: string;
        metadataRegistryImpl: any;
        fromConvert?: boolean;
        sourceMode?: number;
    }
    const modes: {
        STATE: number;
        STATELESS: number;
    };
}
