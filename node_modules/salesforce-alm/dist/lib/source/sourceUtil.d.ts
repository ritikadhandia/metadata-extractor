import { AnyJson } from '@salesforce/ts-types';
import { AggregateSourceElement } from './aggregateSourceElement';
import { MetadataType } from './metadataType';
import { ManifestEntry, SourceOptions } from './types';
import { Config } from '../core/configApi';
import { Env } from '@salesforce/kit';
/**
 * Validate the value for the 'wait' parameter and reset it as a number.
 * @param flags The command parameters (aka flags)
 * @param minWaitTime The minimum allowable time to wait
 */
export declare const parseWaitParam: (flags: {
    wait?: string;
}, minWaitTime?: number) => void;
/**
 * Validate that the org is a non-source-tracked org.
 * @param orgName The username of the org for doing the source:deploy or source:retrieve
 * @param errAction The action ('push' or 'pull') to take when the org is discovered to be a source tracked org.
 */
export declare const validateNonSourceTrackedOrg: (orgName: string, errAction: string) => Promise<void>;
/**
 * Validate that a manifest file path exists and is readable.
 * @param manifestPath The path to the manifest file (package.xml)
 */
export declare const validateManifestPath: (manifestPath: string) => Promise<void>;
export declare function createOutputDir(cmdName: string): Promise<string>;
export declare function cleanupOutputDir(outputDir: string): Promise<void>;
/**
 * Return the aggregate source element for the specified file
 * @param {string} sourcePath the file in the workspace
 * @param sourceWorkspaceAdapter
 * @returns {AggregateSourceElement}
 */
export declare const getSourceElementForFile: (sourcePath: string, sourceWorkspaceAdapter: any, metadataType?: MetadataType) => AggregateSourceElement;
/**
 * Get the source elements from the source path, whether for a particular file or a directory
 * @param {string} optionsSourcePath
 * @param {any} sourceWorkspaceAdapter
 * @returns {Map<string, AggregateSourceElement>}
 */
export declare const getSourceElementsFromSourcePath: (optionsSourcePath: string, sourceWorkspaceAdapter: any) => Promise<Map<string, AggregateSourceElement>>;
/**
 * Return the specified aggregate source element or error if it does not exist
 * @param {Map<string, AggregateSourceElement>} sourceElements All the source elements in the workspace
 * @param {string} key The key of the particular source element we are looking for
 * @param {any} metadataRegistry
 * @returns {AggregateSourceElement}
 */
export declare const loadSourceElement: (sourceElements: Map<string, AggregateSourceElement>, key: string, metadataRegistry: any) => AggregateSourceElement;
/**
 * Return the aggregate source elements found in the provided source path
 * @param {Array<string>} sourcePath The path to look for source elements in
 * @param sourceWorkspaceAdapter
 * @returns {Map<string, AggregateSourceElement>}
 */
export declare const getSourceElementsInPath: (sourcePath: string, sourceWorkspaceAdapter: any) => Map<string, AggregateSourceElement>;
/**
 * Convert the argument into an array datatype
 * @param arrayOrObjectOrUndefined
 * @returns Array
 */
export declare const toArray: (arrayOrObjectOrUndefined: any) => any[];
/**
 * Parse the manifest file and create a list ManifestEntry objects.
 * @param manifestPath {string} The filepath for the manifest
 * @returns {ManifestEntry[]} An array for ManifestEntry objects from the manifest.
 */
export declare const parseToManifestEntriesArray: (manifestPath: string) => Promise<ManifestEntry[]>;
/**
 * Parse manifest entry strings into an array of ManifestEntry objects
 * @param arg {string} The entry string; e.g., "ApexClass, CustomObject:MyObjectName"
 */
export declare const parseManifestEntries: (entries: string) => ManifestEntry[];
/**
 * Converts SourceOptions.metadata into a package manifest for a given org.
 * @param org { any } The org
 * @param options { SourceOptions } The source options containing the metadata
 * @returns {Promise<string | null>} A path to the created manifest or null of options or options.metadata is null.
 */
export declare const toManifest: (org: any, options: SourceOptions, tmpOutputDir?: string) => Promise<string>;
/**
 * Function to create a manifest for a given org
 * @param org {AnyJson} An org
 * @param options {SourceOptions} Source options
 * @param mdPairs {ManifestEntry[]} Array of metadata items
 * @returns A package.xml manifest
 */
export declare const createManifest: (org: AnyJson, options: SourceOptions, mdPairs?: ManifestEntry[], tmpOutputDir?: string) => Promise<{
    file: string;
}>;
/**
 * Used to determine if an error is the result of parsing bad XML. If so return a new parsing error.
 * @param path The file path.
 * @param error The error to inspect.
 */
export declare const checkForXmlParseError: (path: string, error: Error) => Error;
/**
 * @param option containing the metadata type, and sourcepaths if not metadata
 */
export declare const containsMdBundle: (options: any) => boolean;
/**
 * Updates the maxrevision.json with the max RevisionCounter (v47.0) or RevisionNum(v46.0)
 * If members is supplied, it will first check if all those members have a
 * RevisionNum that is NOT null. If any members have a non-null value, then the
 * new max revision is equal to the minimum RevisionNum minus 1; otherwise, the max revision
 * is equal to the maximum RevisionCounter across all source members.
 * This check exists as a workaround for types that may not nullify the RevisionNum
 * when a push is executed.
 */
export declare const updateMaxRevision: (org: any, metadataRegistry: any, members?: any[]) => Promise<any>;
export declare const getMemberNamesFromPushResult: (metadataRegistry: any, pushResult: any) => Promise<string[]>;
/**
 * Determine based on the apiVersion which field is used for tracking the revision number.
 * @param config legacy application parameter.
 * @param env here you can provide a fix env.
 */
export declare function getRevisionFieldName(config?: Config, env?: Env): RevisionCounterField;
export declare enum RevisionCounterField {
    RevisionCounter = "RevisionCounter",
    RevisionNum = "RevisionNum"
}
