import { SourceWorkspaceAdapter } from './sourceWorkspaceAdapter';
import { AggregateSourceElement } from './aggregateSourceElement';
declare class SourceConvertApi {
    static revert?: boolean;
    static err?: Error;
    [property: string]: any;
    constructor(org: any, swa?: SourceWorkspaceAdapter);
    private initWorkspaceAdapter;
    doConvert(context: any): Promise<any[]>;
    convertSourceToMdapi(targetPath: string, packageName: string, aggregateSourceElementsMap: Map<string, AggregateSourceElement>, createDestructiveChangesManifest: boolean, unsupportedMimeTypes: any, isSourceDelete?: boolean): Promise<any[]>;
    /**
     * Sorts the source elements into those that should be added to the destructiveChangesPost.xml
     * and those that should be added to the package.xml
     * @param {Array} aggregateSourceElements - the updated aggregateSourceElements
     * @returns {[[],[]]} - the array of destructive changes and the array of elements to be added to the package.xml
     * @private
     */
    static sortSourceElementsForMdDeploy(aggregateSourceElements: any, metadataRegistry: any): any[][];
    static populateMdDir(targetPath: any, aggregateSourceElements: any, unsupportedMimeTypes?: any, forceIgnore?: any): Promise<any>;
    static createPackageManifests(outputdir: any, packageName: any, destructiveChangesTypeNamePairs: any, updatedAggregateSourceElements: any, scratchOrg: any, metadataRegistry?: any): any;
    static getUpdatedSourceTypeNamePairs(updatedAggregateSourceElements: any, metadataRegistry: any): any;
    static addNoDupes(typeNamePairs: any, typeNamePair: any, keys: any): void;
}
export = SourceConvertApi;
